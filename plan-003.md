### 需求

核心卡牌的数值系统需要简化。
- 我们将玩家也想象成一张特殊的角色牌——皇帝。
- 所有角色牌都应该有 权势、军队、财富、民心，这 4 个绝对数值，绝对数值表示这个是这个角色实际拥有的权势、军队、财富 以及 民心，这些值可以被玩家选择来改变，加或者减。
- 对玩家最重要的并不是自己卡牌的绝对数值，而是自己卡牌的绝对数值在所有上场角色卡里这4 个数值的占比，如果百分比才能决定事件是否激活。
- 所有角色牌还应该有一个独立的健康数值，0-100 范围内。
- 所有角色还应该有一个年龄的数值，随着回合数改变而改变，这个值对健康有影响。

核心玩法流程上，也需要有调整
- 不需要一张卡牌一个回合的设计
- 出场的角色卡，应该和玩家的权势、军队、财富、民心占比的增加而增加，也就是说，玩家权势越大，能决定的事越多，能接触的人就越多，军队值越大，能接触到的武将和军事事件就越多，财富越大，能接触的发展事件就越多，相关的角色也应该更容易被激活，民心越大，平民角色也会越多。
- 一个回合应该尽可能让每个角色都和玩家有一次互动，也就是一个角色一张事件卡。
- 所以每个回合开始，还会需要有一个根据当前状态，激活角色卡的过程。
- 同理，如果玩家的权势降低，也会需要让一些低职位的角色被屏蔽掉。

### 实现方案

1. **角色数据结构调整**
   - 在 `core/types/game.ts` 中为所有角色（包括玩家/皇帝）增加 `power`（权势）、`military`（军队）、`wealth`（财富）、`popularity`（民心）、`health`（健康，0-100）、`age`（年龄）字段。
   - 年龄字段每回合自动递增，健康值可根据年龄和事件动态调整。

2. **数值占比计算与事件激活**
   - 在 `GameEngine` 中实现方法，计算当前所有上场角色的四项数值总和，并据此计算每个角色的占比。
   - 事件激活、角色解锁等逻辑均基于占比而非绝对值。

3. **角色激活与屏蔽机制**
   - 每回合开始时，根据玩家的四项数值占比，动态筛选可激活的角色卡（如权势高则解锁更多高官，军队高则解锁更多武将等）。
   - 若玩家数值下降，自动屏蔽部分低优先级角色（如低职位官员、平民等）。

4. **回合流程调整**
   - 每回合为每个在场角色分配一张事件卡，实现“一回合多事件”。
   - 事件卡的生成与分配基于当前角色状态和全局数值占比。

5. **数据驱动与配置管理**
   - 所有角色与事件数据均存储于 `gameconfig/`，通过 `GameConfigManager.getConfigPath()` 动态加载，严禁硬编码路径。
   - 编辑器与原型项目分别读取 `dev` 和 `stable` 版本数据，确保内容隔离与版本可控。

6. **健康与年龄联动**
   - 在每回合结算时，根据角色年龄增长，健康值按设定规则递减（如高龄角色健康下降更快）。
   - 健康为 0 的角色自动退出场景。

7. **适配层与引擎解耦**
   - UI 层通过 Adapter（如 `GameAdapter`）与核心引擎交互，所有状态变更、事件分发均通过适配器完成，保持架构纯净。

8. **数据校验与内容生成**
   - 新增或修改角色/事件数据后，使用 `ConfigValidator` 进行完整性校验。
   - 编辑器端集成 Gemini API，辅助生成 YAML 格式内容，并实时校验。


---

### 现有实现与本计划的差异与需调整项

1. **角色属性与数值结构**
   - 目前 `CharacterAttributes` 包含 `power`、`loyalty`、`ambition`、`competence`、`reputation`、`health`、`age`，但“军队”“财富”“民心”属性未直接体现在角色属性中，仅在 `CharacterInfluence` 里有体现。需统一角色属性结构，确保所有角色（包括皇帝）都具备“权势、军队、财富、民心、健康、年龄”六项核心属性，并在事件与激活逻辑中以占比方式参与判定。

2. **事件激活与角色筛选机制**
   - 现有 `CardPoolManager` 的事件激活条件主要基于属性阈值（如 minHealth、minAuthority），而非占比。需补充/重构相关逻辑，使事件激活、角色出场与屏蔽机制基于“占比”而非绝对值。

3. **回合流程与事件分配**
   - 当前回合流程通常为“单事件-单角色”，而计划要求“每回合每个角色都分配一张事件卡”。需调整 `GameEngine` 或适配层的回合处理逻辑，确保每回合所有在场角色均有事件互动。

4. **健康与年龄联动**
   - 现有实现中，年龄和健康虽有字段，但健康递减与年龄增长的联动机制未必完善。需确保每回合年龄自动递增，健康值根据年龄和事件动态递减，健康为 0 的角色自动退出。

5. **数据路径与配置管理**
   - 检查所有数据加载、保存路径，确保均通过 `GameConfigManager.getConfigPath()` 获取，严禁硬编码路径。若发现硬编码路径或直接引用 `gameconfig/versions/` 下具体目录的代码，需重构为统一的配置管理方式。

6. **适配层与核心解耦**
   - 确认 UI 层与核心逻辑的交互均通过 Adapter（如 `GameAdapter`），无直接调用 core 内部类型或逻辑的情况。若有直接依赖，需迁移到适配层。

7. **数据校验与内容生成**
   - 编辑器端需确保所有新建/修改的角色与事件数据均通过 `ConfigValidator` 校验，且 Gemini 生成的数据严格遵循 core 类型定义。


---

### editor 项目需同步调整与注意事项

1. **角色属性结构同步**
   - 编辑器的角色编辑、AI 生成、YAML 导出等功能需同步 core 的角色属性结构，确保“权势、军队、财富、民心、健康、年龄”六项属性在所有相关表单、schema、预览和导出中完整体现。
   - 需检查 `dataManager.ts`、`gemini.ts`、`types/game.ts` 等文件，避免遗漏新属性或属性名不一致。

2. **事件激活与占比逻辑支持**
   - 编辑器的事件编辑界面、AI 生成 schema、条件编辑器等需支持基于“占比”而非绝对值的事件激活条件。
   - 需补充相关字段的可视化和校验，避免仅支持 min/max 绝对值。

3. **回合与事件分配预览**
   - 编辑器的事件流程预览、模拟测试等功能需支持“一回合多事件”与“每角色一事件”模式，便于内容创作者直观感受新机制下的事件分配和角色互动。

4. **健康与年龄联动校验**
   - 编辑器需在角色编辑和模拟测试中，支持健康与年龄的联动规则预览和校验，便于发现高龄角色健康递减等问题。

5. **数据路径与版本管理**
   - 检查所有数据读写路径，确保均通过 `GameConfigManager.getConfigPath()` 获取，严禁硬编码。编辑器的“版本切换”功能需与 core 机制保持一致。

6. **类型定义与 schema 自动生成**
   - AI 生成 schema、表单 schema、YAML schema 等需自动同步 core 类型定义，避免手动维护导致的类型漂移。

7. **高级校验与模拟**
   - 编辑器需集成 core 的高级校验、平衡性分析、事件链死锁检测等能力，支持内容创作者在编辑阶段发现潜在问题。

8. **UI/UX 提示与文档**
   - 编辑器界面需对新属性、占比机制、回合分配等新特性提供清晰的说明和实时提示，降低内容创作门槛。


---

### prototype 项目需同步调整与注意事项

1. **角色属性结构同步**
   - prototype 前端展示、角色面板、属性条等需同步 core 的角色属性结构，完整显示“权势、军队、财富、民心、健康、年龄”六项属性。
   - 检查 `CharacterPanel.tsx`、`EmperorStats.tsx`、`types/game.ts` 等，避免属性遗漏或名称不一致。

2. **事件分配与回合流程**
   - 游戏主流程需支持“一回合多事件”，即每回合为每个在场角色分配一张事件卡，UI 需适配批量事件展示与选择。
   - 检查 `GameAdapter`、`EventDisplay.tsx`、`GameHistory.tsx` 等，确保流程与新机制一致。

3. **角色激活与屏蔽机制**
   - 角色出场与屏蔽逻辑需基于“占比”而非绝对值，UI 需能动态反映角色激活/屏蔽状态。

4. **健康与年龄联动**
   - 角色年龄与健康的联动需在 UI 和流程中体现，如高龄角色健康递减、健康为 0 自动退场等。

5. **数据路径与配置管理**
   - 所有数据加载、存档、配置路径均需通过 `GameConfigManager.getConfigPath()` 获取，严禁硬编码。版本切换需与 core 机制一致。

6. **适配层与核心解耦**
   - 所有核心逻辑调用均通过 `GameAdapter` 等适配层完成，UI 层不得直接依赖 core 内部类型或逻辑。

7. **UI/UX 提示与交互**
   - UI 需对新属性、占比机制、批量事件等新特性提供直观展示和交互提示，提升玩家体验。

8. **存档与回溯兼容**
   - 存档结构需同步新属性和机制，确保旧存档兼容性或提供升级方案。